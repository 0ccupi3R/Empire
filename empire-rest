#!/usr/bin/python

import sqlite3, argparse, sys, argparse, logging, json, string, os, re, time
from flask import Flask, request, jsonify, make_response, abort
from time import localtime, strftime
from OpenSSL import SSL
from Crypto.Random import random

# Empire imports
from lib.common import empire


##################################
#
# Helpers.
#
##################################

class Namespace:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)


def get_datetime():
    """
    Return the current date/time
    """
    return strftime("%Y-%m-%d %H:%M:%S", localtime())


##################################
#
# Database interaction methods.
#
##################################

def database_connect():
    """
    Connect with the backend ./empire.db sqlite database and return the
    connection object.
    """
    try:
        # set the database connectiont to autocommit w/ isolation level
        conn = sqlite3.connect('./data/empire.db', check_same_thread=False)
        conn.text_factory = str
        conn.isolation_level = None
        return conn

    except Exception as e:
        print helpers.color("[!] Could not connect to database")
        print helpers.color("[!] Please run database_setup.py")
        sys.exit()


def execute_db_query(conn, query, args=None):
    """
    Execute the supplied query on the provided db conn object
    with optional args for a paramaterized query.
    """
    cur = conn.cursor()
    if(args):
        cur.execute(query, args)
    else:
        cur.execute(query)
    results = cur.fetchall()
    cur.close()
    return results    


def refresh_api_token(conn):
    """
    Generates a randomized RESTful API token and updates the value
    in the config stored in the backend database.
    """

    # generate a randomized API token
    apiToken = ''.join(random.choice(string.ascii_lowercase + string.digits) for x in range(40))

    execute_db_query(conn, "UPDATE config SET api_token=?", [apiToken])

    return apiToken


####################################################################
#
# The Empire RESTful API.
# 
# Adapted from http://blog.miguelgrinberg.com/post/designing-a-restful-api-with-python-and-flask
#   example code at https://gist.github.com/miguelgrinberg/5614326
#
####################################################################

def start_restful_api(port=1337):
    '''
    The Empire RESTful API:

    Verb    URI                                                 Action
    ----    ---                                                 ------
    GET     http://localhost:1337/empire/api/version            return the current Empire version
    
    GET     http://localhost:1337/empire/api/config             return the current default config

    GET     http://localhost:1337/empire/api/stagers            return all current stagers
    GET     http://localhost:1337/empire/api/stagers/X          return the stager with name X
    POST    http://localhost:1337/empire/api/stagers            generate a stager given supplied options (need to implement)

    GET     http://localhost:1337/empire/api/modules            return all current modules

    GET     http://localhost:1337/empire/api/listeners          return all current listeners
    GET     http://localhost:1337/empire/api/listeners/Y        return the listener with id Y
    GET     http://localhost:1337/empire/api/listeners/options  return all listener options
    POST    http://localhost:1337/empire/api/listeners          starts a new listener with the specified options
    DELETE  http://localhost:1337/empire/api/listeners/Y        kills listener Y

    GET     http://localhost:1337/empire/api/agents             return all current agents
    GET     http://localhost:1337/empire/api/agents/Y           return the agent with name Y
    GET     http://localhost:1337/empire/api/agents/Y/results   return tasking results for the agent with name Y
    POST    http://localhost:1337/empire/api/agents/Y           modify or task agent with Y

    GET     http://localhost:1337/empire/api/reporting          return all logged events
    GET     http://localhost:1337/empire/api/reporting/agent/X  return all logged events for the given agent name X
    GET     http://localhost:1337/empire/api/reporting/type/Y   return all logged events of type Y (checkin, task, result, rename)
    GET     http://localhost:1337/empire/api/reporting/msg/Z    return all logged events matching message Z, wildcards accepted
    '''

    app = Flask(__name__)

    # instantiate an Empire instance in case we need to interact with stagers or listeners
    args = Namespace(debug=None, listener=None, stager=None, stager_options=None, version=False)
    main = empire.MainMenu(args=args, restAPI=True)

    conn = database_connect()

    # refresh the token for the RESTful API
    apiToken = refresh_api_token(conn)
    print " * RESTful API token: %s" %(apiToken)

    tokenAllowed = re.compile("^[0-9a-z]{40}")


    # validate API token before every request
    @app.before_request
    def check_token():
        token = request.args.get('token')
        if (not token) or (not tokenAllowed.match(token)):
            return make_response('', 403)
        if token != apiToken:
            return make_response('', 403)


    @app.errorhandler(Exception)
    def exception_handler(error):
        return repr(error)


    @app.errorhandler(404)
    def not_found(error):
        return make_response(jsonify( { 'error': 'Not found' } ), 404)


    @app.route('/empire/api/version', methods=['GET'])
    def get_version():
        """
        Returns the current Empire version.
        """
        return jsonify({'version': empire.VERSION})


    @app.route('/empire/api/config', methods=['GET'])
    def get_config():
        """
        Returns JSON of the current Empire config.
        """
        configRaw = execute_db_query(conn, 'SELECT * FROM config')

        [staging_key, stage0_uri, stage1_uri, stage2_uri, default_delay, default_jitter, default_profile, default_cert_path, default_port, install_path, server_version, ip_whitelist, ip_blacklist, default_lost_limit, autorun_command, autorun_data, api_token] = configRaw[0]
        config = {"version":empire.VERSION, "staging_key":staging_key, "stage0_uri":stage0_uri, "stage1_uri":stage1_uri, "stage2_uri":stage2_uri, "default_delay":default_delay, "default_jitter":default_jitter, "default_profile":default_profile, "default_cert_path":default_cert_path, "default_port":default_port, "install_path":install_path, "server_version":server_version, "ip_whitelist":ip_whitelist, "ip_blacklist":ip_blacklist, "default_lost_limit":default_lost_limit, "autorun_command":autorun_command, "autorun_data":autorun_data, "api_token":api_token}
        return jsonify({'config': config})


    @app.route('/empire/api/stagers', methods=['GET'])
    def get_stagers():
        """
        Returns JSON describing all stagers.
        """
        stagerInfo = {}
        for stagerName,stager in main.stagers.stagers.iteritems():
            info = stager.info
            info['options'] = stager.options
            stagerInfo[stagerName] = info

        return jsonify({'stagers': stagerInfo})


    @app.route('/empire/api/stagers/<string:stager_name>', methods=['GET'])
    def get_stagers_name(stager_name):
        """
        Returns JSON describing the specified stager_name passed.
        """
        stagerInfo = {}
        for stagerName,stager in main.stagers.stagers.iteritems():
            if(stagerName == stager_name):
                info = stager.info
                info['options'] = stager.options
                stagerInfo[stagerName] = info

        return jsonify({'stagers': stagerInfo})


    @app.route('/empire/api/stagers', methods=['POST'])
    def generate_stager():
        """
        Generates a stager with the supplied config and returns JSON information
        describing the generated stager, with 'Output' being the stager output.

        Required JSON args:
            StagerName      -   the stager name to generate
            Listener        -   the Listener name to use for the stager
        """
        if not request.json or not 'StagerName' in request.json or not 'Listener' in request.json:
            abort(400)
        
        stagerName = request.json['StagerName']
        listener = request.json['Listener']

        if stagerName not in main.stagers.stagers:
            return jsonify({'error': 'StagerName invalid'})

        if not main.listeners.is_listener_valid(listener):
            return jsonify({'error': 'invalid listener ID or name'})

        stager = main.stagers.stagers[stagerName]
        
        # set all passed options
        for option,values in request.json.iteritems():
            if option != 'StagerName':
                if(option not in stager.options):
                    return jsonify({'error': 'Invalid option %s, check capitalization.' %(option)})
                stager.options[option]['Value'] = values

        # validate stager options
        for option,values in stager.options.iteritems():
            if values['Required'] and ((not values['Value']) or (values['Value'] == '')):
                return jsonify({'error': 'required stager options missing'})

        stagerOut = stager.options
        stagerOut['Output'] = stager.generate()

        return jsonify({stagerName: stagerOut})


    @app.route('/empire/api/modules', methods=['GET'])
    def get_modules():
        """
        Returns JSON describing all currently loaded modules.
        """
        moduleInfo = {}
        for moduleName,module in main.modules.modules.iteritems():
            info = module.info
            info['options'] = module.options
            moduleInfo[moduleName] = info

        return jsonify({'modules': moduleInfo})


    @app.route('/empire/api/listeners', methods=['GET'])
    def get_listeners():
        """
        Returns JSON describing all currently registered listeners.
        """
        activeListenersRaw = execute_db_query(conn, 'SELECT * FROM listeners')
        activeListeners = {}

        for activeListener in activeListenersRaw:
            [ID,name,host,port,cert_path,staging_key,default_delay,default_jitter,default_profile,kill_date,working_hours,listener_type,redirect_target,default_lost_limit] = activeListener
            activeListeners[name] = {'ID':ID, 'name':name, 'host':host, 'port':port, 'cert_path':cert_path, 'staging_key':staging_key, 'default_delay':default_delay, 'default_jitter':default_jitter, 'default_profile':default_profile, 'kill_date':kill_date, 'working_hours':working_hours, 'listener_type':listener_type, 'redirect_target':redirect_target, 'default_lost_limit':default_lost_limit}

        return jsonify({'listeners' : activeListeners})


    @app.route('/empire/api/listeners/<string:listener_name>', methods=['GET'])
    def get_listener_name(listener_name):
        """
        Returns JSON describing the listener specified by listener_name.
        """
        activeListenersRaw = execute_db_query(conn, 'SELECT * FROM listeners')
        activeListeners = {}

        for activeListener in activeListenersRaw:
            [ID,name,host,port,cert_path,staging_key,default_delay,default_jitter,default_profile,kill_date,working_hours,listener_type,redirect_target,default_lost_limit] = activeListener
            if name == listener_name:
                activeListeners[name] = {'ID':ID, 'name':name, 'host':host, 'port':port, 'cert_path':cert_path, 'staging_key':staging_key, 'default_delay':default_delay, 'default_jitter':default_jitter, 'default_profile':default_profile, 'kill_date':kill_date, 'working_hours':working_hours, 'listener_type':listener_type, 'redirect_target':redirect_target, 'default_lost_limit':default_lost_limit}

        return jsonify({'listeners' : activeListeners})


    @app.route('/empire/api/listeners/<string:listener_name>', methods=['DELETE'])
    def kill_listener(listener_name):
        """
        Kills the listener specified by listener_name.
        """

        if listener_name.lower() == "all":
            activeListenersRaw = execute_db_query(conn, 'SELECT * FROM listeners')
            for activeListener in activeListenersRaw:
                [ID,name,host,port,cert_path,staging_key,default_delay,default_jitter,default_profile,kill_date,working_hours,listener_type,redirect_target,default_lost_limit] = activeListener
                main.listeners.shutdown_listener(name)
                main.listeners.delete_listener(name)

            return jsonify({'result': True})
        else:
            if listener_name != "" and main.listeners.is_listener_valid(listener_name):
                main.listeners.shutdown_listener(listener_name)
                main.listeners.delete_listener(listener_name)
                return jsonify({'result': True})
            else:
                return jsonify({'error': 'invalid listener name: %s' %(listener_name)})


    @app.route('/empire/api/listeners/options', methods=['GET'])
    def get_listener_options():
        """
        Returns JSON describing the current listener options.
        """
        return jsonify({'ListenerOptions' : main.listeners.options})


    @app.route('/empire/api/listeners', methods=['POST'])
    def start_listener():
        """
        Starts a listener with options supplied in the POST.
        """

        # set all passed options
        for option,values in request.json.iteritems():
            returnVal = main.listeners.set_listener_option(option, values)
            if not returnVal:
                return jsonify({'error': 'Error setting listener value %s with option %s' %(option, values)})

        valid = main.listeners.validate_listener_options()
        if not valid:
            return jsonify({'error': 'Error validating listener options'})

        main.listeners.add_listener_from_config()
        return jsonify({'result': True})


    @app.route('/empire/api/agents', methods=['GET'])
    def get_agents():
        """
        Returns JSON describing all currently registered agents.
        """
        activeAgentsRaw = execute_db_query(conn, 'SELECT * FROM agents')
        activeAgents = {}
        
        for activeAgent in activeAgentsRaw:
            [ID, sessionID, listener, name, delay, jitter, external_ip, internal_ip, username, high_integrity, process_name, process_id, hostname, os_details, session_key, checkin_time, lastseen_time, parent, children, servers, uris, old_uris, user_agent, headers, functions, kill_date, working_hours, ps_version, lost_limit, taskings, results] = activeAgent
            activeAgents[name] = {"ID":ID, "sessionID":sessionID, "listener":listener, "name":name, "delay":delay, "jitter":jitter, "external_ip":external_ip, "internal_ip":internal_ip, "username":username, "high_integrity":high_integrity, "process_name":process_name, "process_id":process_id, "hostname":hostname, "os_details":os_details, "session_key":session_key, "checkin_time":checkin_time, "lastseen_time":lastseen_time, "parent":parent, "children":children, "servers":servers, "uris":uris, "old_uris":old_uris, "user_agent":user_agent, "headers":headers, "functions":functions, "kill_date":kill_date, "working_hours":working_hours, "ps_version":ps_version, "lost_limit":lost_limit, "taskings":taskings, "results":results}

        return jsonify({'agents' : activeAgents})


    @app.route('/empire/api/agents/<string:agent_name>', methods=['GET'])
    def get_agents_name(agent_name):
        """
        Returns JSON describing the agent specified by agent_name.
        """
        activeAgentsRaw = execute_db_query(conn, 'SELECT * FROM agents WHERE name=? OR session_id=?', [agent_name, agent_name])
        activeAgents = {}
        
        for activeAgent in activeAgentsRaw:
            [ID, sessionID, listener, name, delay, jitter, external_ip, internal_ip, username, high_integrity, process_name, process_id, hostname, os_details, session_key, checkin_time, lastseen_time, parent, children, servers, uris, old_uris, user_agent, headers, functions, kill_date, working_hours, ps_version, lost_limit, taskings, results] = activeAgent
            activeAgents[name] = {"ID":ID, "sessionID":sessionID, "listener":listener, "name":name, "delay":delay, "jitter":jitter, "external_ip":external_ip, "internal_ip":internal_ip, "username":username, "high_integrity":high_integrity, "process_name":process_name, "process_id":process_id, "hostname":hostname, "os_details":os_details, "session_key":session_key, "checkin_time":checkin_time, "lastseen_time":lastseen_time, "parent":parent, "children":children, "servers":servers, "uris":uris, "old_uris":old_uris, "user_agent":user_agent, "headers":headers, "functions":functions, "kill_date":kill_date, "working_hours":working_hours, "ps_version":ps_version, "lost_limit":lost_limit, "taskings":taskings, "results":results}

        return jsonify({'agents' : activeAgents})


    @app.route('/empire/api/agents/<string:agent_name>/results', methods=['GET'])
    def get_agent_results(agent_name):
        """
        Returns JSON describing the agent's results and removes the result field
        from the backend database.
        """

        agentResults = execute_db_query(conn, 'SELECT results FROM agents WHERE name=? OR session_id=?', [agent_name, agent_name])[0]

        if agentResults and agentResults[0] and agentResults[0] != '':
            out = json.loads(agentResults[0])
            if(out):
                agentResults = "\n".join(out)
            else:
                agentResults = ''
        else:
            agentResults = ''

        execute_db_query(conn, 'UPDATE agents SET results=? WHERE name=? OR session_id=?', ['', agent_name, agent_name])

        return jsonify({agent_name : {'Results': agentResults}})


    # TODO: add get /name/results to get/clear results from DB
    @app.route('/empire/api/agents/<string:agent_name>', methods=['POST'])
    def modify_agent(agent_name):
        """
        Modifies an agent with name agent_name.
        Used for tasking, clearing tasking, setting sleep, renaming, and killing.
        """

        if 'Task' in request.json.keys():

            if agent_name.lower() == "all":
                agent_name = '%'

            taskName = request.json['Task']['TaskName']
            task = request.json['Task']['Task']

            # get existing agent taskings
            agentTasks = execute_db_query(conn, 'SELECT taskings FROM agents WHERE name like ? OR session_id like ?', [agent_name, agent_name])[0]

            if(agentTasks and agentTasks[0]):
                agentTasks = json.loads(agentTasks[0])
            else:
                agentTasks = []

            # append our new json-ified task and update the backend
            agentTasks.append([taskName, task])
            execute_db_query(conn, "UPDATE agents SET taskings=? WHERE name=? OR session_id=?", [json.dumps(agentTasks), agent_name, agent_name])

            execute_db_query(conn, "INSERT INTO reporting (name,event_type,message,time_stamp) VALUES (?,?,?,?)", (agent_name,"task",taskName + " - " + task[0:50], get_datetime()))
            return jsonify({'AgentName':agent_name, 'TaskType':'Task', 'TaskName':taskName, 'Task':task})


        elif 'Clear' in request.json.keys():

            if agent_name.lower() == "all":
                agent_name = '%'

            execute_db_query(conn, "UPDATE agents SET taskings=? WHERE name like ? OR session_id like ?", ['', agent_name, agent_name])

            return jsonify({'AgentName':agent_name, 'TaskType':'Clear', 'TaskName':'', 'Task':''})


        elif 'Rename' in request.json.keys():
            oldName = request.json['Rename']['OldName']
            newName = request.json['Rename']['NewName']

            try:
                main.agents.rename_agent(oldName, newName)
                return jsonify({'result': True})
            except:
                return jsonify({'error': 'error in renaming %s to %s' %(oldName, newName)})
            

        return jsonify({'error':'error in tasking agent %s' % (agent_name)})


    @app.route('/empire/api/agents/<string:agent_name>', methods=['DELETE'])
    def remove_agent(agent_name):
        """
        Removes an agent from the controller specified by agent_name.
        WARNING: doesn't kill the agent first! Ensure the agent is dead.
        """
        if agent_name.lower() == "all":
            agent_name = '%'

        agentsRaw = execute_db_query(conn, 'SELECT * FROM agents WHERE name like ? OR session_id like ?', [agent_name, agent_name])
        removedAgents = {}

        for agent in agentsRaw:
            [ID, sessionID, listener, name, delay, jitter, external_ip, internal_ip, username, high_integrity, process_name, process_id, hostname, os_details, session_key, checkin_time, lastseen_time, parent, children, servers, uris, old_uris, user_agent, headers, functions, kill_date, working_hours, ps_version, lost_limit, taskings, results] = agent
            execute_db_query(conn, "DELETE FROM agents WHERE session_id LIKE ?", [sessionID])

            removedAgents[name] = {"ID":ID, "sessionID":sessionID, "listener":listener, "name":name, "delay":delay, "jitter":jitter, "external_ip":external_ip, "internal_ip":internal_ip, "username":username, "high_integrity":high_integrity, "process_name":process_name, "process_id":process_id, "hostname":hostname, "os_details":os_details, "session_key":session_key, "checkin_time":checkin_time, "lastseen_time":lastseen_time, "parent":parent, "children":children, "servers":servers, "uris":uris, "old_uris":old_uris, "user_agent":user_agent, "headers":headers, "functions":functions, "kill_date":kill_date, "working_hours":working_hours, "ps_version":ps_version, "lost_limit":lost_limit, "taskings":taskings, "results":results}

        return jsonify({'RemovedAgents': removedAgents})


    @app.route('/empire/api/agents/stale', methods=['DELETE'])
    def remove_stale_agent():
        """
        Removes stale agents from the controller.
        WARNING: doesn't kill the agent first! Ensure the agent is dead.
        """
        agentsRaw = execute_db_query(conn, 'SELECT * FROM agents')
        removedAgents = {}
        
        for agent in agentsRaw:
            [ID, sessionID, listener, name, delay, jitter, external_ip, internal_ip, username, high_integrity, process_name, process_id, hostname, os_details, session_key, checkin_time, lastseen_time, parent, children, servers, uris, old_uris, user_agent, headers, functions, kill_date, working_hours, ps_version, lost_limit, taskings, results] = agent

            intervalMax = (delay + delay * jitter)+30

            # get the agent last check in time
            agentTime = time.mktime(time.strptime(lastseen_time, "%Y-%m-%d %H:%M:%S"))

            if agentTime < time.mktime(time.localtime()) - intervalMax:
                execute_db_query(conn, "DELETE FROM agents WHERE session_id LIKE ?", [sessionID])

                removedAgents[name] = {"ID":ID, "sessionID":sessionID, "listener":listener, "name":name, "delay":delay, "jitter":jitter, "external_ip":external_ip, "internal_ip":internal_ip, "username":username, "high_integrity":high_integrity, "process_name":process_name, "process_id":process_id, "hostname":hostname, "os_details":os_details, "session_key":session_key, "checkin_time":checkin_time, "lastseen_time":lastseen_time, "parent":parent, "children":children, "servers":servers, "uris":uris, "old_uris":old_uris, "user_agent":user_agent, "headers":headers, "functions":functions, "kill_date":kill_date, "working_hours":working_hours, "ps_version":ps_version, "lost_limit":lost_limit, "taskings":taskings, "results":results}

        return jsonify({'RemovedAgents': removedAgents})


    @app.route('/empire/api/reporting', methods=['GET'])
    def get_reporting():
        """
        Returns JSON describing the reporting events from the backend database.
        """
        reportingRaw = execute_db_query(conn, 'SELECT * FROM reporting')
        reportingEvents = {}
        
        for reportingEvent in reportingRaw:
            [ID, name, eventType, message, timestamp] = reportingEvent
            reportingEvents[ID] = {"ID":ID, "name":name, "event_type":eventType, "message":message, "timestamp":timestamp}

        return jsonify({'reporting' : reportingEvents})


    @app.route('/empire/api/reporting/agent/<string:reporting_agent>', methods=['GET'])
    def get_reporting_agent(reporting_agent):
        """
        Returns JSON describing the reporting events from the backend database for
        the agent specified by reporting_agent.
        """

        # first resolve the supplied name to a sessionID
        results = execute_db_query(conn, 'SELECT session_id FROM agents WHERE name=?', [reporting_agent])
        if(results):
            sessionID = results[0][0]
        else:
            return jsonify({'reporting' : ''})

        reportingRaw = execute_db_query(conn, 'SELECT * FROM reporting WHERE name=?', [sessionID])
        reportingEvents = {}
        
        for reportingEvent in reportingRaw:
            [ID, name, eventType, message, timestamp] = reportingEvent
            reportingEvents[ID] = {"ID":ID, "name":name, "event_type":eventType, "message":message, "timestamp":timestamp}

        return jsonify({'reporting' : reportingEvents})


    @app.route('/empire/api/reporting/type/<string:event_type>', methods=['GET'])
    def get_reporting_type(event_type):
        """
        Returns JSON describing the reporting events from the backend database for
        the event type specified by event_type.
        """
        reportingRaw = execute_db_query(conn, 'SELECT * FROM reporting WHERE event_type=?', [event_type])
        reportingEvents = {}
        
        for reportingEvent in reportingRaw:
            [ID, name, eventType, message, timestamp] = reportingEvent
            reportingEvents[ID] = {"ID":ID, "name":name, "event_type":eventType, "message":message, "timestamp":timestamp}

        return jsonify({'reporting' : reportingEvents})


    @app.route('/empire/api/reporting/msg/<string:msg>', methods=['GET'])
    def get_reporting_msg(msg):
        """
        Returns JSON describing the reporting events from the backend database for
        the any messages with *msg* specified by msg.
        """
        reportingRaw = execute_db_query(conn, "SELECT * FROM reporting WHERE message like ?", ['%'+msg+'%'])
        reportingEvents = {}
        
        for reportingEvent in reportingRaw:
            [ID, name, eventType, message, timestamp] = reportingEvent
            reportingEvents[ID] = {"ID":ID, "name":name, "event_type":eventType, "message":message, "timestamp":timestamp}

        return jsonify({'reporting' : reportingEvents})

    if not os.path.exists('./data/empire.pem'):
        print "[!] Error: cannot find certificate ./data/empire.pem"
        sys.exit()

    # wrap the Flask connection in SSL and start it
    context = ('./data/empire.pem', './data/empire.pem')
    app.run(host='0.0.0.0', port=port, ssl_context=context, threaded=True)

    if conn: conn.close()


if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('--suppress', action='store_true', help='Suppress all output.')
    args = parser.parse_args()

    if args.suppress:
        # suppress the normal Flask output
        log = logging.getLogger('werkzeug')
        log.setLevel(logging.ERROR)   

    port = 1337
    print "\n * Starting Empire RESTful API on port: %s" %(port)

    start_restful_api(port=1337)
    sys.exit()
